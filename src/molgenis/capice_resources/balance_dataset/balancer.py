import pandas as pd

from molgenis.capice_resources.core import ColumnEnums, AlleleFrequencyEnums
from molgenis.capice_resources.utilities import split_consequences
from molgenis.capice_resources.balance_dataset import BalanceDatasetEnums as Menums
from molgenis.capice_resources.balance_dataset.verbosity_printer import VerbosityPrinter


class Balancer:
    def __init__(self, verbose: bool):
        self.printer = VerbosityPrinter(verbose)
        self.bins = [pd.IntervalIndex]
        self.columns: list[str] = []
        self.drop_benign = pd.Index([])
        self.drop_pathogenic = pd.Index([])
        self.random_state = 5

    @staticmethod
    def _mark_and_impute(dataset: pd.DataFrame) -> None:
        """
        Function to impute samples where the GNOMAD allele frequency is 0.
        Also marks which samples which are imputed.

        Args:
            dataset:
                The pandas.DataFrame containing the gnomAD allele frequency column to be imputed
                (if required).
                Performed inplace.

        """
        dataset[ColumnEnums.IMPUTED.value] = 0
        dataset.loc[dataset[ColumnEnums.GNOMAD_AF.value].isnull(), ColumnEnums.IMPUTED.value] = 1
        dataset[ColumnEnums.GNOMAD_AF.value].fillna(0, inplace=True)

    @staticmethod
    def _reset_impute(dataset: pd.DataFrame) -> None:
        """
        Function to reset imputed samples where the allele frequency has been imputed.
        Not to confuse native "0" allele frequency from imputed ones.

        Args:
            dataset:
                The pandas.DataFrame containing both the gnomAD allele frequency column and the
                "is_imputed" column. Resets allele frequency to nan where it has been imputed.
                Performed inplace.

        """
        dataset.loc[dataset[ColumnEnums.IMPUTED.value] == 1, ColumnEnums.IMPUTED.value] = None
        dataset.drop(columns=[ColumnEnums.IMPUTED.value], inplace=True)

    def _set_bins(self, gnomad_af: pd.Series) -> None:
        """
        Setter for the init variable self.bins, according to both the bins defined in the
        GlobalEnums and the allele frequency ranges present in the gnomAD_AF column.

        Args:
            gnomad_af:
                pandas.Series instance of the dataset "gnomAD_AF" column.

        """
        self.bins = pd.cut(
            gnomad_af,
            bins=AlleleFrequencyEnums.AF_BINS.value,
            right=False,
            include_lowest=True
        ).dropna().unique()
        self.printer.print(f'Bins set: {self.bins}')

    def _set_columns(self, columns: pd.DataFrame.columns) -> None:
        """
        Function to set the columns available for all methods within the Balancer class.

        Args:
            columns:
                The pandas.DataFrame.columns instance of "dataset" after imputing has been
                performed.

        """
        self.columns = list(columns)

    def balance(self, dataset: pd.DataFrame) -> tuple[pd.DataFrame, pd.DataFrame]:
        """
        Primary function of the Balancer class. Loops through each (split) consequence,
        samples pathogenic and benign separately, then calls the "_process_consequence" function.
        After that is done, then filters out the drop Indexes that have been generated by
        "_process_bins" to prevent a multi-consequence sample from being sampled multiple times.

        Args:
            dataset:
                The pandas.Dataframe over which should be balanced.
                Requires the GnomAD_AF column and the Consequence column.
        Returns:
            tuple:
                Tuple containing [0] the balanced dataset over each Consequence over each AF bin
                as per defined in GlobalEnums and
                [1] the remainder dataset of all samples that have not been sampled.

        """
        self._mark_and_impute(dataset)
        self._set_columns(dataset.columns)
        self._set_bins(dataset[ColumnEnums.GNOMAD_AF.value])
        pathogenic = dataset.loc[dataset[dataset[ColumnEnums.BINARIZED_LABEL.value] == 1].index, :]
        benign = dataset.loc[dataset[dataset[ColumnEnums.BINARIZED_LABEL.value] == 0].index, :]
        return_dataset = pd.DataFrame(columns=self.columns)
        consequences = split_consequences(dataset[ColumnEnums.CONSEQUENCE.value])
        for consequence in consequences:
            self.printer.print(f'Processing: {consequence}')
            selected_pathogenic = pathogenic[
                pathogenic[ColumnEnums.CONSEQUENCE.value].str.contains(consequence)
            ]
            self.printer.print(
                f'Total amount of pathogenic samples (for consequence): '
                f'{selected_pathogenic.shape[0]}'
            )
            selected_benign = benign[
                benign[ColumnEnums.CONSEQUENCE.value].str.contains(consequence)
            ]
            self.printer.print(
                f'Total amount of benign samples (for consequence): '
                f'{selected_benign.shape[0]}'
            )
            processed_consequence = self._process_consequence(
                selected_pathogenic,
                selected_benign
            )
            counts = processed_consequence.value_counts(  # One-liner in F-string not possible.
                subset=[Genums.BINARIZED_LABEL.value, Genums.GNOMAD_AF.value]  # type: ignore
            )
            self.printer.print(
                f'Sampled total for consequence: {consequence}\n'
                f'{counts}'
            )
            processed_consequence[Menums.BALANCED_ON.value] = consequence
            return_dataset = pd.concat(
                [
                    return_dataset,
                    processed_consequence
                ], axis=0
            )
            return_dataset.sort_index(inplace=True)
            benign.drop(self.drop_benign, inplace=True)
            self.drop_benign = pd.Index([])
            pathogenic.drop(index=self.drop_pathogenic, inplace=True)
            self.drop_pathogenic = pd.Index([])
        self._reset_impute(return_dataset)
        remainder = pd.concat([benign, pathogenic], ignore_index=True, axis=0)
        self._reset_impute(remainder)
        self.printer.print(f'Balanced set size: {return_dataset.shape[0]}')
        self.printer.print(f'Remainder set size: {remainder.shape[0]}')
        return return_dataset, remainder

    def _sample_variants(self, dataset: pd.DataFrame, n_required: int) -> pd.DataFrame:
        """
        Small function to randomly sample an x amount of samples according to n_required if
        dataset exceeds the n_required.

        Args:
            dataset:
                The pandas.DataFrame that should be checked if the amount of samples is equal to or
                lower than n_required.
            n_required:
                The integer of the amount of samples "dataset" should have at max.
                Does not sample if the amount of samples in "dataset" is lower or equal to
                n_required.

        Returns:
            dataframe:
                Returns a pandas.DataFrame that is the same as input "dataset",
                but randomly sampled to fit a maximum of n_required.

        """
        if dataset.shape[0] > n_required:
            dataset = dataset.sample(n=n_required, random_state=self.random_state)
        return dataset

    def _process_consequence(
            self,
            pathogenic_dataset: pd.DataFrame,
            benign_dataset: pd.DataFrame
    ) -> pd.DataFrame:
        """
        Function to process one specific consequence, which it assumes is already subsetted.
        Does not perform checks if a sample has already been sampled before.
        Does not set the indexes of samples that have to be removed from the initial pathogenic and
        benign subset (without Consequence subset), since it can not know what samples are going
        to be sampled in the allele frequency balancing.

        Args:
            pathogenic_dataset:
                The pandas.DataFrame subset of pathogenic variants, subset further on "Consequence".
            benign_dataset:
                The pandas.DataFrame subset of benign variants, subset further on "Consequence".

        Returns:
            dataframe:
                Returns a pandas.DataFrame that contains variants that have been balanced on the
                allele frequency bins defined in GlobalEnums.
        """
        pathogenic_dataset = self._sample_variants(pathogenic_dataset, benign_dataset.shape[0])
        benign_dataset = self._sample_variants(benign_dataset, pathogenic_dataset.shape[0])
        processed_bins = pd.DataFrame(columns=self.columns)
        for af_bin in self.bins:
            processed_bins = pd.concat(
                [processed_bins, self._process_bins(pathogenic_dataset, benign_dataset, af_bin)],
                axis=0
            )
        return processed_bins

    def _process_bins(self, pathogenic_dataset, benign_dataset, af_bin):
        """
        Function to process an allele frequency bin.
        Does set the indexes of benign and pathogenic sampled variants.
        Calls the "get_variants_within_range", then equalizes between benign and pathogenic by
        randomly sampling.

        Args:
            pathogenic_dataset:
                The subset of pathogenic variants, subset on Consequence, as supplied to
                "_process_consequence" but equalized to the benign subset supplied to
                "_process_consequence".
            benign_dataset:
                The subset of benign variants, subset on Consequence, as supplied to
                "_process_consequence" but equalized to the pathogenic subset supplied to
                "_process_consequence".
            af_bin:
                The pandas.IntervalIndex of the AF bin of interest.

        Returns:
            dataframe:
                Concatenated pandas.DataFrame between pathogenic and benign samples,
                sampled by "af_bin" and then equalized between the amount of benign and
                pathogenic samples.
        """
        selected_pathogenic = self._get_variants_within_range(pathogenic_dataset, af_bin)
        selected_benign = self._get_variants_within_range(benign_dataset, af_bin)
        return_benign = self._sample_variants(selected_benign, selected_pathogenic.shape[0])
        return_pathogenic = self._sample_variants(selected_pathogenic, selected_benign.shape[0])
        self.drop_benign = self.drop_benign.union(return_benign.index).astype(int)
        self.drop_pathogenic = self.drop_pathogenic.union(return_pathogenic.index).astype(int)
        return pd.concat([return_benign, return_pathogenic], axis=0)

    @staticmethod
    def _get_variants_within_range(dataset, af_bin) -> pd.DataFrame:
        """
        Small function to get samples that are within a pandas.IntervalIndex range.

        Args:
            dataset:
                The pandas.DataFrame containing the gnomAD_AF column to get the variants
                that are within the AF bin range.
            af_bin:
                The pandas.IntervalIndex containing the AF bin range.

        Returns:
            dataframe:
                The input "dataset" containing only samples that
                are within the AF range of "af_bin".
        """
        return dataset[dataset[ColumnEnums.GNOMAD_AF.value].apply(lambda value: value in af_bin)]
